// Decompiled with JetBrains decompiler
// Type: WeAreDevs_API.ExploitAPI
// Assembly: WeAreDevs_API, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 70EDAC8E-5221-42DB-9AEB-B82E4E8461FA
// Assembly location: D:\Documentos\Downloads\WeAreDevs_API.dll

using Newtonsoft.Json.Linq;
using System;
using System.Diagnostics;
using System.IO;
using System.IO.Pipes;
using System.Net;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace WeAreDevs_API
{
  public class ExploitAPI
  {
    private WebClient webClient = new WebClient();
    private ExploitAPI.BasicInject injector = new ExploitAPI.BasicInject();
    private int WRDAPIVersion = 9;
    private string luapipe = "WeAreDevsPublicAPI_Lua";
    private string luacpipe = "WeAreDevsPublicAPI_LuaC";
    private bool updateForceRestart;
    private JObject WRDAPICONFCache;
    private JObject latestDataCache;

    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool WaitNamedPipe(string name, int timeout);

    public static bool NamedPipeExist(string pipeName)
    {
      try
      {
        int timeout = 0;
        if (!ExploitAPI.WaitNamedPipe(Path.GetFullPath(string.Format("\\\\.\\pipe\\{0}", (object) pipeName)), timeout))
        {
          switch (Marshal.GetLastWin32Error())
          {
            case 0:
              return false;
            case 2:
              return false;
          }
        }
        return true;
      }
      catch (Exception ex)
      {
        return false;
      }
    }

    private void SMTP(string pipe, string input)
    {
      if (ExploitAPI.NamedPipeExist(pipe))
      {
        try
        {
          using (NamedPipeClientStream pipeClientStream = new NamedPipeClientStream(".", pipe, PipeDirection.Out))
          {
            pipeClientStream.Connect();
            using (StreamWriter streamWriter = new StreamWriter((Stream) pipeClientStream))
            {
              streamWriter.Write(input);
              streamWriter.Dispose();
            }
            pipeClientStream.Dispose();
          }
        }
        catch (IOException ex)
        {
          int num = (int) MessageBox.Show("Error occured sending message to the game!", "Connection Failed!", MessageBoxButtons.OK, MessageBoxIcon.Hand);
        }
        catch (Exception ex)
        {
          int num = (int) MessageBox.Show(ex.Message.ToString());
        }
      }
      else
      {
        int num1 = (int) MessageBox.Show("Error occured. Did the dll properly inject?", "Oops", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
      }
    }

    private string ReadURL(string url) => this.webClient.DownloadString(url);

    private JObject GetWRDAPICONF()
    {
      if (this.WRDAPICONFCache == null)
      {
        if (!System.IO.File.Exists("WRDAPICONF.json"))
          System.IO.File.WriteAllText("WRDAPICONF.json", "{}");
        this.WRDAPICONFCache = JObject.Parse(System.IO.File.ReadAllText("WRDAPICONF.json"));
      }
      return this.WRDAPICONFCache;
    }

    private JObject GetLatestData()
    {
      if (this.latestDataCache == null)
      {
        string str = this.ReadURL("https://cdn.wearedevs.net/software/exploitapi/latestdata.json");
        if (str.Length <= 0)
          str = this.ReadURL("https://raw.githubusercontent.com/WeAreDevs-Official/backups/master/wrdeapi.json");
        this.latestDataCache = JObject.Parse(str);
      }
      return this.latestDataCache;
    }

    public bool IsUpdated()
    {
      JObject latestData = this.GetLatestData();
      if (!((JToken) latestData).HasValues)
      {
        int num = (int) MessageBox.Show("Could not check for the latest version. Did your fireall block us?", "Error");
        return false;
      }
      return !JToken.op_Explicit(latestData["exploit-module"][(object) "patched"]);
    }

    private bool DownloadLatestVersion()
    {
      string address = JToken.op_Explicit(this.GetLatestData()["exploit-module"][(object) "download"]);
      if (address.Length > 0)
      {
        if (System.IO.File.Exists("exploit-main.dll"))
          System.IO.File.Delete("exploit-main.dll");
        this.webClient.DownloadFile(address, "exploit-main.dll");
      }
      return System.IO.File.Exists("exploit-main.dll");
    }

    private void Bootstrap()
    {
      JObject latestData = this.GetLatestData();
      JObject wrdapiconf = this.GetWRDAPICONF();
      if (!System.IO.File.Exists("finj.exe"))
      {
        this.webClient.DownloadFile(JToken.op_Explicit(latestData["qdRFzx_exe"]), "finj.exe");
        wrdapiconf["finjVersion"] = JToken.op_Implicit(JToken.op_Explicit(latestData["finjVersion"]));
        System.IO.File.WriteAllText("WRDAPICONF.json", ((object) wrdapiconf).ToString());
      }
      else if (JToken.op_Explicit(wrdapiconf["finjVersion"]) < JToken.op_Explicit(latestData["finjVersion"]))
      {
        try
        {
          if (System.IO.File.Exists("finj.exe"))
            System.IO.File.Delete("finj.exe");
          if (System.IO.File.Exists("kernel64.sys.dll"))
            System.IO.File.Delete("kernel64.sys.dll");
          this.webClient.DownloadFile(JToken.op_Explicit(latestData["qdRFzx_exe"]), "finj.exe");
          this.webClient.DownloadFile(JToken.op_Explicit(latestData["injDep"]), "kernel64.sys.dll");
          wrdapiconf["finjVersion"] = JToken.op_Implicit(JToken.op_Explicit(latestData["finjVersion"]));
          System.IO.File.WriteAllText("WRDAPICONF.json", ((object) wrdapiconf).ToString());
        }
        catch
        {
        }
      }
      if (!System.IO.File.Exists("kernel64.sys.dll"))
        this.webClient.DownloadFile(JToken.op_Explicit(latestData["injDep"]), "kernel64.sys.dll");
      if (System.IO.File.Exists("old-WeAreDevs_API.dll"))
      {
        try
        {
          System.IO.File.Delete("old-WeAreDevs_API.dll");
        }
        catch
        {
          int num = (int) MessageBox.Show("Downloaded WeAreDevs_API.dll update. Updates will load when you next restart this exploit.", "Update Downloaded - Reload Requested");
        }
      }
      if (!System.IO.File.Exists("old-WeAreDevs_API.dll") && System.IO.File.Exists("WeAreDevs_API.dll") && JToken.op_Explicit(latestData["csapi"][(object) "version"]) > this.WRDAPIVersion)
      {
        System.IO.File.Move("WeAreDevs_API.dll", "old-WeAreDevs_API.dll");
        this.webClient.DownloadFile(JToken.op_Explicit(latestData["csapi"][(object) "download"]), "WeAreDevs_API.dll");
        int num = (int) MessageBox.Show("Downloaded WeAreDevs_API.dll update. Updates will load when you next restart this exploit.", "Update Downloaded - Reload Requested");
        this.updateForceRestart = true;
      }
      if (System.IO.File.Exists("Module2.dll"))
      {
        try
        {
          System.IO.File.Delete("Module2.dll");
        }
        catch
        {
        }
      }
      if (System.IO.File.Exists("deleteme"))
      {
        try
        {
          System.IO.File.Delete("deleteme");
        }
        catch
        {
        }
      }
      if (System.IO.File.Exists("i.exe"))
      {
        try
        {
          System.IO.File.Delete("qdRFzx.exe");
        }
        catch
        {
        }
      }
      if (!System.IO.File.Exists("qdRFzx.exe"))
        return;
      try
      {
        System.IO.File.Delete("qdRFzx.exe");
      }
      catch
      {
      }
    }

    public bool isAPIAttached() => ExploitAPI.NamedPipeExist(this.luapipe);

    public bool LaunchExploit()
    {
      this.Bootstrap();
      if (this.updateForceRestart)
      {
        int num = (int) MessageBox.Show("Downloaded WeAreDevs_API.dll update. Updates will load when you next restart this exploit.", "Update Downloaded - Reload Requested");
        return false;
      }
      if (ExploitAPI.NamedPipeExist(this.luapipe))
        return true;
      if (!this.IsUpdated())
      {
        int num1 = (int) MessageBox.Show("Exploit is currently patched... Please wait for the developers to fix it! Meanwhile, check wearedevs.net for updates/info.", "Error");
      }
      if (!this.DownloadLatestVersion())
      {
        int num2 = (int) MessageBox.Show("Could not download the latest version! Did your firewall block us?", "Error");
      }
      if (!System.IO.File.Exists("finj.exe"))
      {
        int num3 = (int) MessageBox.Show("A depedency is missing even after being redownloaded. Please be sure yout anti-virus is disabled then restart the exploit.");
        return false;
      }
      new Process()
      {
        StartInfo = {
          FileName = "finj.exe"
        }
      }.Start();
      return true;
    }

    public async void AutoAttach()
    {
      Process Proc = Process.GetProcessesByName("RobloxPlayerBeta")[0];
      do
      {
        await Task.Delay(1500);
      }
      while (!(Proc.MainWindowHandle != IntPtr.Zero));
      this.LaunchExploit();
      Proc = (Process) null;
    }

    public bool LegacyLaunchExploit()
    {
      if (ExploitAPI.NamedPipeExist(this.luapipe))
        return true;
      if (!this.IsUpdated())
      {
        int num1 = (int) MessageBox.Show("Exploit is currently patched... Please wait for the developers to fix it! Meanwhile, check wearedevs.net for updates/info.", "Error");
      }
      if (!this.DownloadLatestVersion())
      {
        int num2 = (int) MessageBox.Show("Could not download the latest version! Did your firewall block us?", "Error");
      }
      if (this.injector.InjectDLL())
        return true;
      int num3 = (int) MessageBox.Show("DLL failed to inject", "Error");
      return false;
    }

    [Obsolete("SendScript is deprecated, please use SendLuaCScript instead.")]
    public void SendScript(string script) => this.SendLuaCScript(script);

    public void SendLuaCScript(string Script)
    {
      foreach (string input in Script.Split("\r\n".ToCharArray()))
      {
        try
        {
          this.SMTP(this.luacpipe, input);
        }
        catch (Exception ex)
        {
          int num = (int) MessageBox.Show(ex.Message.ToString());
        }
      }
    }

    [Obsolete("SendLimitedLuaScript is deprecated, please use SendLuaScript instead.")]
    public void SendLimitedLuaScript(string script) => this.SendLuaScript(script);

    public void SendLuaScript(string Script) => this.SMTP(this.luapipe, Script);

    public void LuaC_getglobal(string service) => this.SendLuaCScript("getglobal " + service);

    public void LuaC_getfield(int index, string instance) => this.SendLuaCScript("getglobal " + index.ToString() + " " + instance);

    public void LuaC_setfield(int index, string property) => this.SendLuaCScript("setfield " + index.ToString() + " " + property);

    public void LuaC_pushvalue(int index) => this.SendLuaCScript("pushvalue " + index.ToString());

    public void LuaC_pushstring(string text) => this.SendLuaCScript("pushstring " + text);

    public void LuaC_pushnumber(int number) => this.SendLuaCScript("pushnumber " + number.ToString());

    public void LuaC_pcall(int numberOfArguments, int numberOfResults, int ErrorFunction) => this.SendLuaCScript("pushnumber " + numberOfArguments.ToString() + " " + numberOfResults.ToString() + " " + ErrorFunction.ToString());

    public void LuaC_settop(int index) => this.SendLuaCScript("settop " + index.ToString());

    public void LuaC_pushboolean(string value = "false") => this.SendLuaCScript("pushboolean " + value);

    public void LuaC_gettop() => this.SendLuaCScript("gettop");

    public void LuaC_pushnil() => this.SendLuaCScript("pushnil");

    public void LuaC_next(int index) => this.SendLuaCScript("next");

    public void LuaC_pop(int quantity) => this.SendLuaCScript("pop " + quantity.ToString());

    public void DoBTools(string username = "me") => this.SendLuaScript("loadstring(game:HttpGet(\"https://cdn.wearedevs.net/scripts/BTools.txt\"))()");

    public void Suicide(string username = "me") => this.SendLuaScript("game:GetService(\"Players\").LocalPlayer.Character:BreakJoints()");

    public void AddForcefield(string username = "me") => this.SendLuaScript("Instance.new(\"ForceField\", game:GetService(\"Players\").LocalPlayer.Character)");

    public void RemoveForceField(string username = "me") => this.SendLuaScript("game:GetService(\"Players\").LocalPlayer.Character.ForceField:Destroy()");

    public void ToggleFloat(string username = "me") => this.SendLuaScript("loadstring(game:HttpGet(\"https://cdn.wearedevs.net/scripts/Float Character.txt\"))()");

    public void RemoveLimbs(string username = "me")
    {
      this.SendLuaScript("loadstring(game:HttpGet(\"https://cdn.wearedevs.net/scripts/Remove Arms.txt\"))()");
      this.SendLuaScript("loadstring(game:HttpGet(\"https://cdn.wearedevs.net/scripts/Remove Legs.txt\"))()");
    }

    public void RemoveArms(string username = "me") => this.SendLuaScript("loadstring(game:HttpGet(\"https://cdn.wearedevs.net/scripts/Remove Arms.txt\"))()");

    public void RemoveLegs(string username = "me") => this.SendLuaScript("loadstring(game:HttpGet(\"https://cdn.wearedevs.net/scripts/Remove Legs.txt\"))()");

    public void AddFire(string username = "me") => this.SendLuaScript("Instance.new(\"Fire\", game:GetService(\"Players\").LocalPlayer.Character.HumanoidRootPart)");

    public void RemoveFire(string username = "me") => this.SendLuaScript("game:GetService(\"Players\").LocalPlayer.Character.HumanoidRootPart.Fire:Destroy()");

    public void AddSparkles(string username = "me") => this.SendLuaScript("Instance.new(\"Sparkles\", game:GetService(\"Players\").LocalPlayer.Character.HumanoidRootPart)");

    public void RemoveSparkles(string username = "me") => this.SendLuaScript("game:GetService(\"Players\").LocalPlayer.Character.HumanoidRootPart.Sparkles:Destroy()");

    public void AddSmoke(string username = "me") => this.SendLuaScript("Instance.new(\"Smoke\", game:GetService(\"Players\").LocalPlayer.Character.HumanoidRootPart)");

    public void RemoveSmoke(string username = "me") => this.SendLuaScript("game:GetService(\"Players\").LocalPlayer.Character.HumanoidRootPart.Smoke:Destroy()");

    public void DoBlockHead(string username = "me") => this.SendLuaScript("game:GetService(\"Players\").LocalPlayer.Character.Head.Mesh:Destroy()");

    public void ConsolePrint(string text = "") => this.SendLuaScript("rconsoleprint " + text);

    public void ConsoleWarn(string text = "") => this.SendLuaScript("rconsolewarn " + text);

    public void ConsoleError(string text = "") => this.SendLuaScript("rconsoleerr " + text);

    public void SetWalkSpeed(string username = "me", int value = 100) => this.SendLuaScript("game:GetService(\"Players\").LocalPlayer.Character.Humanoid.WalkSpeed = " + value.ToString());

    public void ToggleClickTeleport() => this.SendLuaScript("loadstring(game:HttpGet(\"https://cdn.wearedevs.net/scripts/Click Teleport.txt\"))()");

    public void SetFogStart(int value = 0) => this.SendLuaScript("game:GetService(\"Lighting\").FogStart = " + value.ToString());

    public void SetFogEnd(int value = 0) => this.SendLuaScript("game:GetService(\"Lighting\").FogEnd = " + value.ToString());

    public void SetJumpPower(int value = 100) => this.SendLuaScript("game:GetService(\"Players\").LocalPlayer.Character.Humanoid.JumpPower = " + value.ToString());

    public void TeleportToPlayer(string targetUsername = "me") => this.SendLuaScript("game:GetService(\"Players\").LocalPlayer.Character:MoveTo(game:GetService(\"Players\"):FindFirstChild(" + targetUsername + ").Character.HumanoidRootPart.Position)");

    private class BasicInject
    {
      [DllImport("kernel32", CharSet = CharSet.Ansi, SetLastError = true)]
      internal static extern IntPtr LoadLibraryA(string lpFileName);

      [DllImport("kernel32", CharSet = CharSet.Ansi, SetLastError = true)]
      internal static extern UIntPtr GetProcAddress(IntPtr hModule, string procName);

      [DllImport("kernel32.dll", SetLastError = true)]
      [return: MarshalAs(UnmanagedType.Bool)]
      internal static extern bool FreeLibrary(IntPtr hModule);

      [DllImport("kernel32.dll")]
      internal static extern IntPtr OpenProcess(
        ExploitAPI.BasicInject.ProcessAccess dwDesiredAccess,
        [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle,
        int dwProcessId);

      [DllImport("kernel32.dll", SetLastError = true)]
      internal static extern IntPtr VirtualAllocEx(
        IntPtr hProcess,
        IntPtr lpAddress,
        uint dwSize,
        uint flAllocationType,
        uint flProtect);

      [DllImport("kernel32.dll", SetLastError = true)]
      internal static extern bool WriteProcessMemory(
        IntPtr hProcess,
        IntPtr lpBaseAddress,
        byte[] lpBuffer,
        uint nSize,
        out UIntPtr lpNumberOfBytesWritten);

      [DllImport("kernel32.dll")]
      internal static extern IntPtr CreateRemoteThread(
        IntPtr hProcess,
        IntPtr lpThreadAttributes,
        uint dwStackSize,
        UIntPtr lpStartAddress,
        IntPtr lpParameter,
        uint dwCreationFlags,
        out IntPtr lpThreadId);

      [DllImport("kernel32.dll", SetLastError = true)]
      internal static extern bool ReadProcessMemory(
        IntPtr hProcess,
        IntPtr lpBaseAddress,
        [Out] byte[] lpBuffer,
        int dwSize,
        out int lpNumberOfBytesRead);

      public bool InjectDLL()
      {
        if (Process.GetProcessesByName("RobloxPlayerBeta").Length == 0)
          return false;
        Process process = Process.GetProcessesByName("RobloxPlayerBeta")[0];
        byte[] bytes = new ASCIIEncoding().GetBytes(AppDomain.CurrentDomain.BaseDirectory + "exploit-main.dll");
        IntPtr hModule = ExploitAPI.BasicInject.LoadLibraryA("kernel32.dll");
        UIntPtr procAddress = ExploitAPI.BasicInject.GetProcAddress(hModule, "LoadLibraryA");
        ExploitAPI.BasicInject.FreeLibrary(hModule);
        if (procAddress == UIntPtr.Zero)
          return false;
        IntPtr hProcess = ExploitAPI.BasicInject.OpenProcess(ExploitAPI.BasicInject.ProcessAccess.AllAccess, false, process.Id);
        if (hProcess == IntPtr.Zero)
          return false;
        IntPtr num = ExploitAPI.BasicInject.VirtualAllocEx(hProcess, (IntPtr) 0, (uint) bytes.Length, 12288U, 4U);
        return !(num == IntPtr.Zero) && ExploitAPI.BasicInject.WriteProcessMemory(hProcess, num, bytes, (uint) bytes.Length, out UIntPtr _) && !(ExploitAPI.BasicInject.CreateRemoteThread(hProcess, (IntPtr) 0, 0U, procAddress, num, 0U, out IntPtr _) == IntPtr.Zero);
      }

      [Flags]
      public enum ProcessAccess
      {
        AllAccess = 1050235, // 0x0010067B
        CreateThread = 2,
        DuplicateHandle = 64, // 0x00000040
        QueryInformation = 1024, // 0x00000400
        SetInformation = 512, // 0x00000200
        Terminate = 1,
        VMOperation = 8,
        VMRead = 16, // 0x00000010
        VMWrite = 32, // 0x00000020
        Synchronize = 1048576, // 0x00100000
      }
    }
  }
}
